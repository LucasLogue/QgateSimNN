"""physics.py – classical trajectory utilities for the co‑moving PINN
--------------------------------------------------------------------
Located in  brevmachine/uberpwnage/zz/physics.py  (i.e. the *zz* package).
The helper functions wrap all ODE / interpolation logic behind a single, memoised
call so your training script can stay clean:

    from zz.physics import get_classical_traj
    traj = get_classical_traj(t0=0.0, t1=3.0)
    Xc,  Xc_dot  = traj.X, traj.X_dot   # callables

All figures generated by this module are saved automatically to
   brevmachine/uberpwnage/zz/zzoutput/
(no need to pass paths around).
"""
from __future__ import annotations

# std‑lib
from dataclasses import dataclass
from functools import lru_cache
from pathlib import Path
from typing import Tuple, Callable

# third‑party
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

# ---------------------------------------------------------------------------
# project paths
# ---------------------------------------------------------------------------
ZZ_ROOT    = Path(__file__).resolve().parent            #  .../uberpwnage/zz
ZZ_OUTPUT  = ZZ_ROOT / "zzoutput"                       #  .../uberpwnage/zz/zzoutput
ZZ_OUTPUT.mkdir(parents=True, exist_ok=True)

# ---------------------------------------------------------------------------
# external field E(t)
# ---------------------------------------------------------------------------
_DEF_E_PARAMS = dict(A=-6.3, sigma=1.7, omega=1.13, phi=0.64, t0=0.0)

def E_t_np(t: float | np.ndarray, *, A: float=-6.3, sigma: float=1.7,
            omega: float=1.13, phi: float=0.64, t0: float=0.0) -> np.ndarray:
    """Gaussian‑enveloped sine pulse (NumPy backend)."""
    return A * np.exp(-((t - t0) / sigma) ** 2) * np.sin(omega * t + phi)

# ---------------------------------------------------------------------------
# classical trajectory integration
# ---------------------------------------------------------------------------
@dataclass(frozen=True, slots=True)
class ClassicalTraj:
    """Container for the cubic‑spline interpolants."""
    t_grid : np.ndarray                    # 1‑D grid used by the spline
    X      : Callable[[np.ndarray], np.ndarray]  # x_c(t)
    X_dot  : Callable[[np.ndarray], np.ndarray]  # \dot{x}_c(t)

@lru_cache(maxsize=None)
def _integrate_traj(t0: float, t1: float,
                   *, n_pts: int = 500) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Solve the classical ODE once & cache the result (NumPy arrays)."""
    def ode(t, state):
        x, p = state  # p == \dot{x}
        dxdt  = p
        dpdt  = -x - E_t_np(t, **_DEF_E_PARAMS)  # harmonic + external field
        return dxdt, dpdt

    t_eval = np.linspace(t0, t1, n_pts)
    sol    = solve_ivp(ode, [t0, t1], y0=[0.0, 0.0], t_eval=t_eval, dense_output=True)
    return sol.t, sol.y[0], sol.y[1]

@lru_cache(maxsize=None)
def get_classical_traj(t0: float = 0.0, t1: float = 3.0) -> ClassicalTraj:
    """Public helper – returns *memoised* spline callables Xc(t), Xc_dot(t)."""
    from scipy.interpolate import CubicSpline

    t, x, v = _integrate_traj(t0, t1)
    X_spline     = CubicSpline(t, x, extrapolate=True)
    Xdot_spline  = CubicSpline(t, v, extrapolate=True)
    return ClassicalTraj(t_grid=t, X=X_spline, X_dot=Xdot_spline)

# ---------------------------------------------------------------------------
# diagnostics – run `python -m zz.physics` to visualise the trajectory
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    traj = get_classical_traj(0.0, 3.0)

    # --- numeric sanity prints -------------------------------------------------
    print("Xc(3.0)      =", traj.X(3.0))
    print("dXc/dt(3.0) =", traj.X_dot(3.0))

    t_plot = np.linspace(0.0, 3.0, 400)
    fig, ax = plt.subplots(1, 2, figsize=(7, 3.5), dpi=120)
    ax[0].plot(t_plot, traj.X(t_plot));  ax[0].set_title("Xc(t)")
    ax[1].plot(t_plot, traj.X_dot(t_plot)); ax[1].set_title("Xc_dot(t)")
    for a in ax: a.set_xlabel("t")
    fig.tight_layout()
    out_path = ZZ_OUTPUT / "classical_traj.png"
    fig.savefig(out_path)
    print(f"[physics] trajectory figure saved → {out_path.relative_to(ZZ_ROOT)}")
